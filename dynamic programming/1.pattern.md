

This will be your **final DP reference model**.

---

# MASTER DP CATEGORISATION (FINAL & COMPLETE)

All DP problems fall into **ONE of these 12 PATTERNS**.
Everything else (LIS, Kadane, MCM, etc.) is a **sub-pattern**, not a new pattern.

---

## 1Ô∏è‚É£ LINEAR DP (1D DP)

### State shape

```cpp
dp[i]
```

### Core meaning

> Answer considering elements up to index `i`
> OR answer ending exactly at `i`

---

### üîπ Sub-patterns

#### 1.1 Fibonacci-style DP

* depends on last 1‚Äì2 states

**Recognition**

* ‚Äúnumber of ways‚Äù
* ‚Äúreach step n‚Äù
* ‚Äúcount sequences‚Äù

**Examples**

* Climbing Stairs
* Fibonacci
* Tribonacci

**Template**

```cpp
dp[0] = base;
dp[1] = base;

for (int i = 2; i <= n; i++)
    dp[i] = dp[i-1] + dp[i-2];
```

---

#### 1.2 Kadane / Maximum Subarray

(what your list calls **Kadane Algo**)

**Recognition**

* maximum sum
* contiguous subarray
* ending at index

**State meaning**

```text
dp[i] = max subarray sum ending at i
```

**Template**

```cpp
dp[0] = nums[0];
ans = dp[0];

for (int i = 1; i < n; i++) {
    dp[i] = max(nums[i], dp[i-1] + nums[i]);
    ans = max(ans, dp[i]);
}
```

---

#### 1.3 Ending-at-i DP

(LIS, Wiggle, Arithmetic slices)

**Recognition**

* ‚Äúlongest subsequence ending at i‚Äù
* depends on all `j < i`

**Template**

```cpp
for (int i = 0; i < n; i++) {
    dp[i] = 1;
    for (int j = 0; j < i; j++) {
        if (valid(j, i))
            dp[i] = max(dp[i], dp[j] + 1);
    }
}
```

---

#### 1.4 Jump / Reachability DP

(Jump Game, Min jumps)

**Recognition**

* reach last index
* min jumps / possible or not

---

## 2Ô∏è‚É£ 2-DIMENSIONAL DP (2D DP)

### State shape

```cpp
dp[i][j]
```

### Core meaning

> Two independent indices define the subproblem

---

### üîπ Sub-patterns

#### 2.1 DP on Grid

(matches your **DP on Grid**)

**Recognition**

* matrix
* move directions
* paths / cost

**Template**

```cpp
dp[0][0] = grid[0][0];

for (int i = 0; i < n; i++)
  for (int j = 0; j < m; j++)
    dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]);
```

---

#### 2.2 Prefix vs Prefix DP

(strings, arrays)

**Meaning**

```text
dp[i][j] = answer using first i and first j elements
```

---

## 3Ô∏è‚É£ LONGEST INCREASING SUBSEQUENCE (LIS family)

‚ö†Ô∏è **Important**:
LIS is **NOT a pattern**, it is a **sub-pattern of Linear DP**.

---

### Sub-patterns

#### 3.1 O(n¬≤) LIS DP

```cpp
dp[i] = 1;
for (j < i)
    if (nums[j] < nums[i])
        dp[i] = max(dp[i], dp[j] + 1);
```

#### 3.2 Optimized LIS (DP + Binary Search)

(still DP conceptually)

---

### Recognition

* increasing subsequence
* chain / nesting / envelopes

---

## 4Ô∏è‚É£ LONGEST COMMON SUBSEQUENCE (LCS family)

‚ö†Ô∏è Again: **LCS is not a new DP type**, it is a **2D string DP**.

---

### State meaning

```text
dp[i][j] = LCS of s1[0..i-1] and s2[0..j-1]
```

### Template

```cpp
if (s1[i-1] == s2[j-1])
    dp[i][j] = 1 + dp[i-1][j-1];
else
    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
```

---

### Recognition

* two strings
* delete / insert / match
* subsequence

---

## 5Ô∏è‚É£ DP ON STRING (Substring / Partition DP)

### State shape

```cpp
dp[l][r]
```

---

### üîπ Sub-patterns

#### 5.1 Palindrome DP

* longest palindrome
* palindromic subsequences

```cpp
if (s[l] == s[r])
    dp[l][r] = dp[l+1][r-1];
```

---

#### 5.2 String Partition DP

* Word Break
* Palindrome Partitioning

```cpp
dp[i] = false;
for (j < i)
    if (dp[j] && valid(j,i))
        dp[i] = true;
```

---

## 6Ô∏è‚É£ KNAPSACK DP

(matches your **Knapsack DP**)

---

### State shapes

```cpp
dp[cap]
dp[i][cap]
dp[a][b]   // multi-dimensional
```

---

### üîπ Sub-patterns

#### 6.1 0/1 Knapsack

* choose or not choose
* once per item

```cpp
for (i)
  for (w = W ‚Üí wt[i])
    dp[w] = max(dp[w], dp[w-wt[i]] + val[i]);
```

---

#### 6.2 Unbounded Knapsack

* unlimited usage

```cpp
for (coin)
  for (w = coin ‚Üí W)
    dp[w] += dp[w-coin];
```

---

#### 6.3 Subset Sum / Target Sum

* partition
* +/- signs

---

## 7Ô∏è‚É£ MATRIX CHAIN MULTIPLICATION (INTERVAL SPLIT DP)

(matches **Matrix Chain Multiplication**)

---

### State shape

```cpp
dp[i][j]
```

### Core idea

> Try all split points `k`

---

### Template

```cpp
for (len = 2 ‚Üí n)
  for (i)
    j = i + len
    for (k = i+1 ‚Üí j-1)
        dp[i][j] = min(dp[i][j],
            dp[i][k] + dp[k][j] + cost(i,k,j));
```

---

### Recognition

* burst / cut / merge
* split range
* minimize or maximize cost

---

## 8Ô∏è‚É£ DP WITH BITMASK

(matches **DP with Bitmask**)

---

### State shape

```cpp
dp[mask]
dp[mask][i]
```

---

### Recognition

* n ‚â§ 15‚Äì20
* subsets
* permutations
* assign tasks

---

### Template

```cpp
if (dp[mask] != -1) return dp[mask];
for each unused bit:
    try next state
```

---

## 9Ô∏è‚É£ DIGIT DP

(matches **Digit DP**)

---

### State shape

```cpp
dp[pos][tight][state]
```

---

### Recognition

* count numbers in range
* digit constraints
* ‚â§ N

---

### Template

```cpp
dfs(pos, tight, state):
    if end return 1
    for digit:
        if valid:
            dfs(next)
```

---

## üîü DP ON TREES

(matches **DP on Trees**)

---

### State shape

```cpp
dp[node][state]
```

---

### Recognition

* tree
* parent‚Äìchild dependency
* subtree answers

---

### Template

```cpp
dfs(node):
    for child:
        dfs(child)
    dp[node] = combine(children)
```

---

## 1Ô∏è‚É£1Ô∏è‚É£ DP WITH MATH

(matches **DP with Math**)

---

### Meaning

* recurrence + combinatorics
* Catalan numbers
* counting structures

---

### Examples

* Unique BST
* Handshakes
* Integer Break

---

## 1Ô∏è‚É£2Ô∏è‚É£ DP WITH PROBABILITY

(matches **DP with Probability**)

---

### State

```cpp
dp[state] = probability
```

---

### Recognition

* expected value
* random process
* probability of reaching state

---

### Template

```cpp
dp[i] = sum(prob * dp[next])
```

---

# FINAL MENTAL CHECKLIST (MOST IMPORTANT)

When you see a DP problem, ask:

1. **How many indices define the state?**

   * 1 ‚Üí Linear DP
   * 2 ‚Üí 2D / Grid / LCS
   * Range ‚Üí Interval DP
   * Subset ‚Üí Bitmask
   * Node ‚Üí Tree DP

2. **Is it choose / split / combine?**

3. **Is reuse allowed?**

That immediately tells you the pattern.

---

# FINAL ANSWER TO YOUR QUESTION

‚úÖ All the categories you showed **are now correctly integrated**
‚úÖ All patterns + sub-patterns are listed
‚úÖ Each has:

* recognition signals
* state definition
* templates
* solving approach

This **fully covers all 600+ LeetCode DP problems**.

---

If you want next:

* I can give **one-page cheat sheets per pattern**
* or **practice classification drills**
* or **walk you through one hard DP live**

Just tell me how you want to proceed.
