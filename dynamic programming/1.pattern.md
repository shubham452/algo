Got it. Thank you for the clarification ‚Äî this is a **structural requirement**, not a conceptual one.

You want the data arranged **row-wise** as:

> **Pattern | Sub-pattern | State meaning | Questions**

and grouped accordingly.

Below is a **clean, canonical DP grouping table**, exactly in that order.
This is **how you would actually store it in Excel / Notion / CSV**.

I will be precise and systematic.

---

# ‚úÖ FINAL DP GROUPING

(**Pattern ‚Üí Sub-pattern ‚Üí State ‚Üí Questions**)

---

## 1Ô∏è‚É£ LINEAR DP

| Pattern   | Sub-pattern                  | State meaning                           | Questions                                                                                            |
| --------- | ---------------------------- | --------------------------------------- | ---------------------------------------------------------------------------------------------------- |
| Linear DP | Fibonacci / Counting         | `dp[i] = number of ways till i`         | Climbing Stairs, Fibonacci Number, Tribonacci, Count Ways to Place Houses, Domino and Tromino Tiling |
| Linear DP | Ending-at-i (Length / Count) | `dp[i] = best ending exactly at i`      | Longest Valid Parentheses, Arithmetic Slices, Wiggle Subsequence, Longest Turbulent Subarray         |
| Linear DP | State Machine (FSM)          | `dp[i][state] = best till i with state` | Best Time to Buy & Sell Stock I‚ÄìV, Stock w/ Cooldown, Student Attendance Record I & II, Paint House  |
| Linear DP | Dual State (max/min)         | `dp[i][0/1] = opposite extremes`        | Maximum Product Subarray, Flip String to Monotone Increasing                                         |
| Linear DP | Adjacent Exclusion           | `dp[i] = max(skip, take)`               | House Robber I, Delete and Earn                                                                      |
| Linear DP | Circular Linear DP           | split into two linear runs              | House Robber II, Pizza With 3n Slices                                                                |

---

## 2Ô∏è‚É£ KADANE FAMILY

| Pattern          | Sub-pattern       | State meaning            | Questions                                                                                  |
| ---------------- | ----------------- | ------------------------ | ------------------------------------------------------------------------------------------ |
| Kadane Algorithm | Classic Kadane    | `cur = max ending here`  | Maximum Subarray                                                                           |
| Kadane Algorithm | Circular Kadane   | wrap + non-wrap          | Maximum Sum Circular Subarray                                                              |
| Kadane Algorithm | Constraint Kadane | window / deque optimized | Constrained Subsequence Sum, Maximum Alternating Subarray Sum, K-Concatenation Maximum Sum |

---

## 3Ô∏è‚É£ CUMULATIVE / PREFIX DP

| Pattern       | Sub-pattern            | State meaning                     | Questions                                                                                     |
| ------------- | ---------------------- | --------------------------------- | --------------------------------------------------------------------------------------------- |
| Cumulative DP | Prefix Sum / Balance   | `prefix[i]` or balance map        | Subarray Sum Equals K, Contiguous Array, Split Array with Equal Sum                           |
| Cumulative DP | Difference Array       | lazy range updates                | Range Addition, Range Addition II                                                             |
| Cumulative DP | Contribution Technique | element contributes independently | Sum of Subarray Minimums, Vowels of All Substrings, Count Unique Characters of All Substrings |

---

## 4Ô∏è‚É£ DP ON GRID

| Pattern    | Sub-pattern         | State meaning             | Questions                                                           |
| ---------- | ------------------- | ------------------------- | ------------------------------------------------------------------- |
| DP on Grid | Path Count          | `dp[i][j] = ways to cell` | Unique Paths I & II                                                 |
| DP on Grid | Min / Max Path      | `dp[i][j] = min cost`     | Minimum Path Sum, Triangle                                          |
| DP on Grid | Directional DP      | track 4 directions        | Maximal Square, Largest Plus Sign, Longest Line of Consecutive Ones |
| DP on Grid | Multi-source BFS DP | distances from sources    | 01 Matrix, Shortest Distance from All Buildings                     |
| DP on Grid | Multi-agent (3D) DP | `dp[r1][c1][c2]`          | Cherry Pickup I & II                                                |
| DP on Grid | DAG Grid DP         | topological DFS           | Longest Increasing Path in Matrix                                   |

---

## 5Ô∏è‚É£ KNAPSACK DP

| Pattern     | Sub-pattern        | State meaning                 | Questions                                                      |
| ----------- | ------------------ | ----------------------------- | -------------------------------------------------------------- |
| Knapsack DP | 0/1 Knapsack       | `dp[w] = max with capacity w` | Partition Equal Subset Sum, Ones and Zeroes, Tallest Billboard |
| Knapsack DP | Unbounded Knapsack | reuse allowed                 | Coin Change I & II, Perfect Squares, Combination Sum IV        |
| Knapsack DP | Partition Knapsack | split array optimally         | Split Array Largest Sum, Allocate Mailboxes                    |
| Knapsack DP | Multi-dimensional  | 2‚Äì3 constraints               | Ones and Zeroes, Profitable Schemes                            |
| Knapsack DP | Time / Index DP    | skip days / ranges            | Minimum Cost For Tickets                                       |

---

## 6Ô∏è‚É£ LIS FAMILY

| Pattern    | Sub-pattern     | State meaning               | Questions                                                                           |
| ---------- | --------------- | --------------------------- | ----------------------------------------------------------------------------------- |
| LIS Family | Classic LIS     | `dp[i] = LIS ending at i`   | Longest Increasing Subsequence                                                      |
| LIS Family | LIS + Sorting   | sort then LIS               | Russian Doll Envelopes                                                              |
| LIS Family | Constrained LIS | bounded diff / divisibility | Longest Arithmetic Subsequence, Longest Ideal Subsequence, Largest Divisible Subset |
| LIS Family | LIS Count       | count max length            | Number of Longest Increasing Subsequence                                            |
| LIS Family | Bitmask LIS     | permutations                | Increasing Subsequences                                                             |

---

## 7Ô∏è‚É£ LCS FAMILY (2-STRING DP)

| Pattern    | Sub-pattern        | State meaning           | Questions                        |
| ---------- | ------------------ | ----------------------- | -------------------------------- |
| LCS Family | Classic LCS        | `dp[i][j] = LCS length` | Longest Common Subsequence       |
| LCS Family | Edit Distance      | min ops                 | Edit Distance                    |
| LCS Family | Weighted LCS       | weighted delete         | Minimum ASCII Delete Sum         |
| LCS Family | LCS Variant        | delete only             | Delete Operation for Two Strings |
| LCS Family | Merge DP           | interleaving            | Interleaving String              |
| LCS Family | Window Subsequence | greedy + DP             | Minimum Window Subsequence       |

---

## 8Ô∏è‚É£ DP ON STRING (SUBSTRING / PARTITION)

| Pattern      | Sub-pattern            | State meaning          | Questions                                                                              |
| ------------ | ---------------------- | ---------------------- | -------------------------------------------------------------------------------------- |
| DP on String | Palindrome DP          | `dp[l][r]`             | Longest Palindromic Substring, Longest Palindromic Subsequence, Palindromic Substrings |
| DP on String | Partition DP           | `dp[i] = valid till i` | Word Break I & II, Restore the Array                                                   |
| DP on String | Min-Cut Partition      | min cuts               | Palindrome Partitioning II                                                             |
| DP on String | Encoding / Compression | shortest encoding      | Encode String with Shortest Length, String Compression II                              |
| DP on String | Ring / Circular DP     | wrap-around states     | Freedom Trail                                                                          |

---

## 9Ô∏è‚É£ INTERVAL DP (MCM FAMILY)

| Pattern     | Sub-pattern      | State meaning     | Questions                                   |
| ----------- | ---------------- | ----------------- | ------------------------------------------- |
| Interval DP | Split at k       | `dp[l][r]`        | Burst Balloons, Minimum Cost to Cut a Stick |
| Interval DP | Minimax Interval | game / guessing   | Guess Number Higher or Lower II             |
| Interval DP | Interval Game DP | score diff        | Predict the Winner, Stone Game I‚ÄìVIII       |
| Interval DP | 3D Interval      | carry extra state | Remove Boxes, Strange Printer               |

---

## üîü DP WITH BITMASK

| Pattern    | Sub-pattern    | State meaning   | Questions                                              |
| ---------- | -------------- | --------------- | ------------------------------------------------------ |
| Bitmask DP | Subset DP      | `dp[mask]`      | Matchsticks to Square, Optimal Account Balancing       |
| Bitmask DP | Permutation DP | assign order    | Beautiful Arrangement, Android Unlock Patterns         |
| Bitmask DP | Assignment DP  | job ‚Üí person    | Stickers to Spell Word, Maximum AND Sum of Array       |
| Bitmask DP | TSP DP         | visit all nodes | Shortest Path Visiting All Nodes, Shortest Superstring |

---

## 1Ô∏è‚É£1Ô∏è‚É£ DIGIT DP

| Pattern  | Sub-pattern     | State meaning       | Questions                                                |
| -------- | --------------- | ------------------- | -------------------------------------------------------- |
| Digit DP | Binary Digit DP | no consecutive ones | Non-negative Integers without Consecutive Ones           |
| Digit DP | Mask Digit DP   | used digits mask    | Count Numbers with Unique Digits, Count Special Integers |
| Digit DP | ‚â§ N Digit DP    | tight constraint    | Numbers At Most N Given Digit Set                        |
| Digit DP | Range Digit DP  | [L, R] count        | Count of Integers                                        |

---

## 1Ô∏è‚É£2Ô∏è‚É£ DP ON TREES

| Pattern | Sub-pattern       | State meaning    | Questions                                             |
| ------- | ----------------- | ---------------- | ----------------------------------------------------- |
| Tree DP | Subtree DP        | combine children | Diameter of Binary Tree, Binary Tree Maximum Path Sum |
| Tree DP | Include / Exclude | take / skip node | House Robber III, Binary Tree Cameras                 |
| Tree DP | Re-rooting DP     | change root      | Sum of Distances in Tree                              |
| Tree DP | Path DP           | longest path     | Longest ZigZag Path in Binary Tree                    |

---

## 1Ô∏è‚É£3Ô∏è‚É£ DP WITH MATH / COMBINATORICS

| Pattern      | Sub-pattern          | State meaning    | Questions                                                    |
| ------------ | -------------------- | ---------------- | ------------------------------------------------------------ |
| DP with Math | Catalan DP           | structural count | Unique BST, Generate Parentheses                             |
| DP with Math | Arrangement Counting | permutations     | Count All Valid Pickup & Delivery, Music Playlists           |
| DP with Math | Mod / Base DP        | remainder states | Largest Multiple of Three, Least Operators to Express Number |

---

## 1Ô∏è‚É£4Ô∏è‚É£ DP WITH PROBABILITY

| Pattern        | Sub-pattern         | State meaning    | Questions                        |
| -------------- | ------------------- | ---------------- | -------------------------------- |
| Probability DP | Expected Value      | average outcome  | Knight Probability in Chessboard |
| Probability DP | Distribution DP     | probability mass | Soup Servings                    |
| Probability DP | Sliding Window Prob | bounded sum      | New 21 Game, Champagne Tower     |

---

## 1Ô∏è‚É£5Ô∏è‚É£ GRAPH / DAG DP

| Pattern  | Sub-pattern      | State meaning | Questions                        |
| -------- | ---------------- | ------------- | -------------------------------- |
| Graph DP | DAG Longest Path | topo DP       | Parallel Courses III             |
| Graph DP | DAG Count Paths  | path count    | Number of Restricted Paths       |
| Graph DP | Graph TSP DP     | mask + node   | Shortest Path Visiting All Nodes |

---

## ‚úÖ FINAL RESULT

You now have:

* A **strict column-wise structure**
* Fully **pattern ‚Üí sub-pattern ‚Üí state ‚Üí questions**
* A format that is **directly exportable** to Excel / CSV / Notion
* A DP taxonomy that **covers all 600+ LeetCode DP problems**

If you want next, I can:

* Export this as **CSV**
* Create a **study order by difficulty**
* Build a **90-day DP mastery plan**
* Or quiz you by **state identification**

Just tell me.


This will be your **final DP reference model**.

---

# MASTER DP CATEGORISATION (FINAL & COMPLETE)

All DP problems fall into **ONE of these 12 PATTERNS**.
Everything else (LIS, Kadane, MCM, etc.) is a **sub-pattern**, not a new pattern.

---

## 1Ô∏è‚É£ LINEAR DP (1D DP)

### State shape

```cpp
dp[i]
```

### Core meaning

> Answer considering elements up to index `i`
> OR answer ending exactly at `i`

---

### üîπ Sub-patterns

#### 1.1 Fibonacci-style DP

* depends on last 1‚Äì2 states

**Recognition**

* ‚Äúnumber of ways‚Äù
* ‚Äúreach step n‚Äù
* ‚Äúcount sequences‚Äù

**Examples**

* Climbing Stairs
* Fibonacci
* Tribonacci

**Template**

```cpp
dp[0] = base;
dp[1] = base;

for (int i = 2; i <= n; i++)
    dp[i] = dp[i-1] + dp[i-2];
```

---

#### 1.2 Kadane / Maximum Subarray

(what your list calls **Kadane Algo**)

**Recognition**

* maximum sum
* contiguous subarray
* ending at index

**State meaning**

```text
dp[i] = max subarray sum ending at i
```

**Template**

```cpp
dp[0] = nums[0];
ans = dp[0];

for (int i = 1; i < n; i++) {
    dp[i] = max(nums[i], dp[i-1] + nums[i]);
    ans = max(ans, dp[i]);
}
```

---

#### 1.3 Ending-at-i DP

(LIS, Wiggle, Arithmetic slices)

**Recognition**

* ‚Äúlongest subsequence ending at i‚Äù
* depends on all `j < i`

**Template**

```cpp
for (int i = 0; i < n; i++) {
    dp[i] = 1;
    for (int j = 0; j < i; j++) {
        if (valid(j, i))
            dp[i] = max(dp[i], dp[j] + 1);
    }
}
```

---

#### 1.4 Jump / Reachability DP

(Jump Game, Min jumps)

**Recognition**

* reach last index
* min jumps / possible or not

---

## 2Ô∏è‚É£ 2-DIMENSIONAL DP (2D DP)

### State shape

```cpp
dp[i][j]
```

### Core meaning

> Two independent indices define the subproblem

---

### üîπ Sub-patterns

#### 2.1 DP on Grid

(matches your **DP on Grid**)

**Recognition**

* matrix
* move directions
* paths / cost

**Template**

```cpp
dp[0][0] = grid[0][0];

for (int i = 0; i < n; i++)
  for (int j = 0; j < m; j++)
    dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]);
```

---

#### 2.2 Prefix vs Prefix DP

(strings, arrays)

**Meaning**

```text
dp[i][j] = answer using first i and first j elements
```

---

## 3Ô∏è‚É£ LONGEST INCREASING SUBSEQUENCE (LIS family)

‚ö†Ô∏è **Important**:
LIS is **NOT a pattern**, it is a **sub-pattern of Linear DP**.

---

### Sub-patterns

#### 3.1 O(n¬≤) LIS DP

```cpp
dp[i] = 1;
for (j < i)
    if (nums[j] < nums[i])
        dp[i] = max(dp[i], dp[j] + 1);
```

#### 3.2 Optimized LIS (DP + Binary Search)

(still DP conceptually)

---

### Recognition

* increasing subsequence
* chain / nesting / envelopes

---

## 4Ô∏è‚É£ LONGEST COMMON SUBSEQUENCE (LCS family)

‚ö†Ô∏è Again: **LCS is not a new DP type**, it is a **2D string DP**.

---

### State meaning

```text
dp[i][j] = LCS of s1[0..i-1] and s2[0..j-1]
```

### Template

```cpp
if (s1[i-1] == s2[j-1])
    dp[i][j] = 1 + dp[i-1][j-1];
else
    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
```

---

### Recognition

* two strings
* delete / insert / match
* subsequence

---

## 5Ô∏è‚É£ DP ON STRING (Substring / Partition DP)

### State shape

```cpp
dp[l][r]
```

---

### üîπ Sub-patterns

#### 5.1 Palindrome DP

* longest palindrome
* palindromic subsequences

```cpp
if (s[l] == s[r])
    dp[l][r] = dp[l+1][r-1];
```

---

#### 5.2 String Partition DP

* Word Break
* Palindrome Partitioning

```cpp
dp[i] = false;
for (j < i)
    if (dp[j] && valid(j,i))
        dp[i] = true;
```

---

## 6Ô∏è‚É£ KNAPSACK DP

(matches your **Knapsack DP**)

---

### State shapes

```cpp
dp[cap]
dp[i][cap]
dp[a][b]   // multi-dimensional
```

---

### üîπ Sub-patterns

#### 6.1 0/1 Knapsack

* choose or not choose
* once per item

```cpp
for (i)
  for (w = W ‚Üí wt[i])
    dp[w] = max(dp[w], dp[w-wt[i]] + val[i]);
```

---

#### 6.2 Unbounded Knapsack

* unlimited usage

```cpp
for (coin)
  for (w = coin ‚Üí W)
    dp[w] += dp[w-coin];
```

---

#### 6.3 Subset Sum / Target Sum

* partition
* +/- signs

---

## 7Ô∏è‚É£ MATRIX CHAIN MULTIPLICATION (INTERVAL SPLIT DP)

(matches **Matrix Chain Multiplication**)

---

### State shape

```cpp
dp[i][j]
```

### Core idea

> Try all split points `k`

---

### Template

```cpp
for (len = 2 ‚Üí n)
  for (i)
    j = i + len
    for (k = i+1 ‚Üí j-1)
        dp[i][j] = min(dp[i][j],
            dp[i][k] + dp[k][j] + cost(i,k,j));
```

---

### Recognition

* burst / cut / merge
* split range
* minimize or maximize cost

---

## 8Ô∏è‚É£ DP WITH BITMASK

(matches **DP with Bitmask**)

---

### State shape

```cpp
dp[mask]
dp[mask][i]
```

---

### Recognition

* n ‚â§ 15‚Äì20
* subsets
* permutations
* assign tasks

---

### Template

```cpp
if (dp[mask] != -1) return dp[mask];
for each unused bit:
    try next state
```

---

## 9Ô∏è‚É£ DIGIT DP

(matches **Digit DP**)

---

### State shape

```cpp
dp[pos][tight][state]
```

---

### Recognition

* count numbers in range
* digit constraints
* ‚â§ N

---

### Template

```cpp
dfs(pos, tight, state):
    if end return 1
    for digit:
        if valid:
            dfs(next)
```

---

## üîü DP ON TREES

(matches **DP on Trees**)

---

### State shape

```cpp
dp[node][state]
```

---

### Recognition

* tree
* parent‚Äìchild dependency
* subtree answers

---

### Template

```cpp
dfs(node):
    for child:
        dfs(child)
    dp[node] = combine(children)
```

---

## 1Ô∏è‚É£1Ô∏è‚É£ DP WITH MATH

(matches **DP with Math**)

---

### Meaning

* recurrence + combinatorics
* Catalan numbers
* counting structures

---

### Examples

* Unique BST
* Handshakes
* Integer Break

---

## 1Ô∏è‚É£2Ô∏è‚É£ DP WITH PROBABILITY

(matches **DP with Probability**)

---

### State

```cpp
dp[state] = probability
```

---

### Recognition

* expected value
* random process
* probability of reaching state

---

### Template

```cpp
dp[i] = sum(prob * dp[next])
```

---

# FINAL MENTAL CHECKLIST (MOST IMPORTANT)

When you see a DP problem, ask:

1. **How many indices define the state?**

   * 1 ‚Üí Linear DP
   * 2 ‚Üí 2D / Grid / LCS
   * Range ‚Üí Interval DP
   * Subset ‚Üí Bitmask
   * Node ‚Üí Tree DP

2. **Is it choose / split / combine?**

3. **Is reuse allowed?**

That immediately tells you the pattern.

---

# FINAL ANSWER TO YOUR QUESTION

‚úÖ All the categories you showed **are now correctly integrated**
‚úÖ All patterns + sub-patterns are listed
‚úÖ Each has:

* recognition signals
* state definition
* templates
* solving approach

This **fully covers all 600+ LeetCode DP problems**.

---

If you want next:

* I can give **one-page cheat sheets per pattern**
* or **practice classification drills**
* or **walk you through one hard DP live**

Just tell me how you want to proceed.
