# ðŸ§  DYNAMIC PROGRAMMING â€” TEMPLATES & EXPLANATIONS FOR EACH PATTERN AND SUBPATTERN

Below you will find **concise explanations** and **C++ templates** for each DP pattern and subpattern identified in the previous categorization. These templates capture the core logic; you can adapt them to specific problems by adjusting the state definition, transition, and base cases.

---

## ðŸŸ¢ Pattern 1 â€” Linear DP (1D)

### 1.1 Fibonacci Style
**When to use:** Problems where the answer depends on previous one or two values (e.g., climbing stairs, house robber, decode ways).  
**State meaning:** `dp[i]` = answer for first i elements / value at i.

```cpp
// Template
int fibStyle(int n) {
    if (n <= 1) return n;
    vector<int> dp(n + 1);
    dp[0] = 0; dp[1] = 1; // base cases
    for (int i = 2; i <= n; ++i) {
        dp[i] = dp[i-1] + dp[i-2]; // transition (may be more complex)
    }
    return dp[n];
}
// Space-optimized: use two variables instead of array
```

**Key insight:** Often the transition is `dp[i] = dp[i-1] + dp[i-2]` or `dp[i] = max(dp[i-1], dp[i-2] + value[i])` (House Robber).

---

### 1.2 Maximum Subarray / Product
**When to use:** Find contiguous subarray with maximum sum/product.  
**State meaning:** `dp[i]` = best subarray ending at i.

```cpp
// Maximum subarray (Kadane)
int maxSubArray(vector<int>& nums) {
    int cur = nums[0], best = nums[0];
    for (int i = 1; i < nums.size(); ++i) {
        cur = max(nums[i], cur + nums[i]);
        best = max(best, cur);
    }
    return best;
}

// Maximum product subarray (need to track min as well)
int maxProduct(vector<int>& nums) {
    int curMax = nums[0], curMin = nums[0], best = nums[0];
    for (int i = 1; i < nums.size(); ++i) {
        if (nums[i] < 0) swap(curMax, curMin);
        curMax = max(nums[i], curMax * nums[i]);
        curMin = min(nums[i], curMin * nums[i]);
        best = max(best, curMax);
    }
    return best;
}
```

**Key insight:** For product, negative * negative gives positive, so maintain both max and min ending at i.

---

### 1.3 1D Game / Jump
**When to use:** Jump games where you can move from i to i + jump.  
**State meaning:** `dp[i]` = can reach i / min steps to i.

```cpp
// Can reach end?
bool canJump(vector<int>& nums) {
    int maxReach = 0;
    for (int i = 0; i < nums.size(); ++i) {
        if (i > maxReach) return false;
        maxReach = max(maxReach, i + nums[i]);
    }
    return true;
}

// Minimum jumps (BFS-like DP)
int jump(vector<int>& nums) {
    int n = nums.size();
    vector<int> dp(n, INT_MAX);
    dp[0] = 0;
    for (int i = 0; i < n; ++i) {
        for (int j = 1; j <= nums[i] && i + j < n; ++j) {
            dp[i+j] = min(dp[i+j], dp[i] + 1);
        }
    }
    return dp[n-1];
}
// Optimized with greedy: O(n)
```

**Key insight:** For "minimum jumps", use BFS-like or greedy (maintain current end of jump, next farthest).

---

### 1.4 Partition / Split
**When to use:** Splitting a sequence into parts where each part must satisfy a condition.  
**State meaning:** `dp[i]` = best way to split first i elements.

```cpp
// Word Break (whether can be segmented)
bool wordBreak(string s, vector<string>& wordDict) {
    unordered_set<string> dict(wordDict.begin(), wordDict.end());
    int n = s.size();
    vector<bool> dp(n + 1, false);
    dp[0] = true;
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (dp[j] && dict.count(s.substr(j, i - j))) {
                dp[i] = true;
                break;
            }
        }
    }
    return dp[n];
}

// Palindrome Partitioning II (min cuts)
int minCut(string s) {
    int n = s.size();
    vector<int> dp(n, INT_MAX); // dp[i] = min cuts for s[0..i]
    vector<vector<bool>> pal(n, vector<bool>(n, false));
    // precompute palindromes
    for (int i = 0; i < n; ++i) {
        int minCut = i; // worst case: each char a cut
        for (int j = 0; j <= i; ++j) {
            if (s[j] == s[i] && (i - j <= 2 || pal[j+1][i-1])) {
                pal[j][i] = true;
                minCut = (j == 0) ? 0 : min(minCut, dp[j-1] + 1);
            }
        }
        dp[i] = minCut;
    }
    return dp[n-1];
}
```

**Key insight:** Usually iterate over possible last partition [j,i] and combine with dp[j-1].

---

### 1.5 Stock Series
**When to use:** Best time to buy/sell stock with various constraints.  
**State meaning:** `dp[i][k][hold]` = max profit up to day i with at most k transactions and whether holding a stock.

```cpp
// General template for at most K transactions
int maxProfit(int K, vector<int>& prices) {
    int n = prices.size();
    if (n <= 1) return 0;
    // if K is large, use greedy
    if (K >= n/2) {
        int profit = 0;
        for (int i = 1; i < n; ++i)
            if (prices[i] > prices[i-1])
                profit += prices[i] - prices[i-1];
        return profit;
    }
    vector<vector<int>> dp(K+1, vector<int>(n, 0));
    for (int k = 1; k <= K; ++k) {
        int maxDiff = -prices[0];
        for (int i = 1; i < n; ++i) {
            dp[k][i] = max(dp[k][i-1], prices[i] + maxDiff);
            maxDiff = max(maxDiff, dp[k-1][i-1] - prices[i]);
        }
    }
    return dp[K][n-1];
}
```

**Key insight:** For infinite transactions, just sum all upward moves. For cooldown/fee, adjust transitions.

---

### 1.6 Counting / Combinatorics
**When to use:** Count number of ways to achieve something (paths, arrangements).  
**State meaning:** `dp[i]` = number of ways for i.

```cpp
// Unique Paths
int uniquePaths(int m, int n) {
    vector<vector<int>> dp(m, vector<int>(n, 1));
    for (int i = 1; i < m; ++i)
        for (int j = 1; j < n; ++j)
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
    return dp[m-1][n-1];
}

// Or 1D space
vector<int> dp(n, 1);
for (int i = 1; i < m; ++i)
    for (int j = 1; j < n; ++j)
        dp[j] += dp[j-1];
```

**Key insight:** Many combinatorial DPs are just sums of previous states; watch out for modulo.

---

## ðŸŸ¢ Pattern 2 â€” Grid / 2D DP

### 2.1 Paths / Sums
**When to use:** Moving in grid, accumulating min/max sum.  
**State meaning:** `dp[i][j]` = best value / ways to reach (i,j).

```cpp
// Minimum Path Sum
int minPathSum(vector<vector<int>>& grid) {
    int m = grid.size(), n = grid[0].size();
    vector<vector<int>> dp(m, vector<int>(n));
    dp[0][0] = grid[0][0];
    for (int i = 1; i < m; ++i) dp[i][0] = dp[i-1][0] + grid[i][0];
    for (int j = 1; j < n; ++j) dp[0][j] = dp[0][j-1] + grid[0][j];
    for (int i = 1; i < m; ++i)
        for (int j = 1; j < n; ++j)
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];
    return dp[m-1][n-1];
}
```

**Key insight:** Often only two directions (right/down); use 1D DP to save space.

---

### 2.2 Maximal Square / Rectangle
**When to use:** Find largest square/rectangle of 1's in binary matrix.  
**State meaning:** `dp[i][j]` = side length of largest square ending at (i,j).

```cpp
// Maximal Square
int maximalSquare(vector<vector<char>>& matrix) {
    int m = matrix.size(), n = matrix[0].size();
    vector<vector<int>> dp(m, vector<int>(n, 0));
    int maxSide = 0;
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            if (matrix[i][j] == '1') {
                if (i == 0 || j == 0) dp[i][j] = 1;
                else dp[i][j] = min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]}) + 1;
                maxSide = max(maxSide, dp[i][j]);
            }
        }
    }
    return maxSide * maxSide;
}
```

**Key insight:** For maximal rectangle (85), need histogram approach or DP with heights.

---

### 2.3 Bomb / Obstacles (Miscellaneous)
**When to use:** Various grid problems with specific rules.  
**State meaning:** Depends on problem (e.g., max enemies killed).  
No single template; adapt to problem.

---

## ðŸŸ¢ Pattern 3 â€” Subsequence / String DP

### 3.1 Longest Increasing Subsequence (LIS)
**When to use:** Find longest increasing subsequence.  
**State meaning:** `dp[i]` = length of LIS ending at i (O(nÂ²)) or maintain tails array (O(n log n)).

```cpp
// O(n log n) using binary search
int lengthOfLIS(vector<int>& nums) {
    vector<int> tails;
    for (int x : nums) {
        auto it = lower_bound(tails.begin(), tails.end(), x);
        if (it == tails.end()) tails.push_back(x);
        else *it = x;
    }
    return tails.size();
}
```

**Key insight:** For counting number of LIS, need extra `count` array.

---

### 3.2 Longest Common Subsequence (LCS)
**When to use:** Find longest common subsequence of two strings.  
**State meaning:** `dp[i][j]` = LCS of first i chars of s1 and first j of s2.

```cpp
int longestCommonSubsequence(string text1, string text2) {
    int m = text1.size(), n = text2.size();
    vector<vector<int>> dp(m+1, vector<int>(n+1, 0));
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (text1[i-1] == text2[j-1])
                dp[i][j] = dp[i-1][j-1] + 1;
            else
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
        }
    }
    return dp[m][n];
}
```

**Key insight:** Can be space-optimized to 1D.

---

### 3.3 Arithmetic / Geometric
**When to use:** Find longest arithmetic subsequence (difference constant).  
**State meaning:** `dp[i][diff]` = length of arithmetic subsequence ending at i with difference diff.

```cpp
// Longest Arithmetic Subsequence (O(nÂ²))
int longestArithSeqLength(vector<int>& nums) {
    int n = nums.size();
    vector<unordered_map<int,int>> dp(n);
    int best = 2;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            int diff = nums[i] - nums[j];
            dp[i][diff] = dp[j].count(diff) ? dp[j][diff] + 1 : 2;
            best = max(best, dp[i][diff]);
        }
    }
    return best;
}
```

**Key insight:** Use hashmap for diff because range may be large.

---

### 3.4 Distinct Subsequences
**When to use:** Count distinct subsequences of s equal to t.  
**State meaning:** `dp[i][j]` = number of distinct subsequences of s[0:i] equal to t[0:j].

```cpp
int numDistinct(string s, string t) {
    int m = s.size(), n = t.size();
    vector<vector<unsigned long>> dp(m+1, vector<unsigned long>(n+1, 0));
    for (int i = 0; i <= m; ++i) dp[i][0] = 1;
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            dp[i][j] = dp[i-1][j];
            if (s[i-1] == t[j-1])
                dp[i][j] += dp[i-1][j-1];
        }
    }
    return dp[m][n];
}
```

**Key insight:** When characters match, you can either include or exclude current s char.

---

### 3.5 Palindrome
**When to use:** Problems involving palindromic substrings/subsequences.  
**State meaning:** `dp[i][j]` = whether s[i..j] is palindrome / length.

```cpp
// Longest Palindromic Substring (expand around center is better, but DP also works)
string longestPalindrome(string s) {
    int n = s.size();
    vector<vector<bool>> dp(n, vector<bool>(n, false));
    int start = 0, maxLen = 1;
    for (int i = 0; i < n; ++i) dp[i][i] = true;
    for (int len = 2; len <= n; ++len) {
        for (int i = 0; i + len - 1 < n; ++i) {
            int j = i + len - 1;
            if (s[i] == s[j] && (len == 2 || dp[i+1][j-1])) {
                dp[i][j] = true;
                if (len > maxLen) { start = i; maxLen = len; }
            }
        }
    }
    return s.substr(start, maxLen);
}

// Longest Palindromic Subsequence
int longestPalindromeSubseq(string s) {
    int n = s.size();
    vector<vector<int>> dp(n, vector<int>(n, 0));
    for (int i = n-1; i >= 0; --i) {
        dp[i][i] = 1;
        for (int j = i+1; j < n; ++j) {
            if (s[i] == s[j])
                dp[i][j] = dp[i+1][j-1] + 2;
            else
                dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
        }
    }
    return dp[0][n-1];
}
```

**Key insight:** For subsequence, process intervals from end to beginning.

---

## ðŸŸ¢ Pattern 4 â€” Interval DP

### 4.1 Merging / Bursting
**When to use:** Problems where you combine intervals (e.g., burst balloons, matrix chain multiplication).  
**State meaning:** `dp[i][j]` = max result from interval [i,j].

```cpp
// Burst Balloons template
int maxCoins(vector<int>& nums) {
    int n = nums.size();
    nums.insert(nums.begin(), 1);
    nums.push_back(1);
    vector<vector<int>> dp(n+2, vector<int>(n+2, 0));
    for (int len = 1; len <= n; ++len) {
        for (int left = 1; left <= n - len + 1; ++left) {
            int right = left + len - 1;
            for (int k = left; k <= right; ++k) {
                dp[left][right] = max(dp[left][right],
                    dp[left][k-1] + dp[k+1][right] + nums[left-1]*nums[k]*nums[right+1]);
            }
        }
    }
    return dp[1][n];
}
```

**Key insight:** Usually iterate over interval length and choose last element to combine left and right.

---

### 4.2 Game Theory
**When to use:** Two players take turns picking from ends, maximize your score difference.  
**State meaning:** `dp[i][j]` = max score current player can achieve from subarray [i,j].

```cpp
// Stone Game (predict winner)
bool stoneGame(vector<int>& piles) {
    int n = piles.size();
    vector<vector<int>> dp(n, vector<int>(n, 0));
    for (int i = 0; i < n; ++i) dp[i][i] = piles[i];
    for (int len = 2; len <= n; ++len) {
        for (int i = 0; i + len - 1 < n; ++i) {
            int j = i + len - 1;
            dp[i][j] = max(piles[i] - dp[i+1][j], piles[j] - dp[i][j-1]);
        }
    }
    return dp[0][n-1] > 0;
}
```

**Key insight:** Use difference; `dp[i][j]` = max difference (current - opponent) for subarray [i,j].

---

## ðŸŸ¢ Pattern 5 â€” Tree DP

### 5.1 Binary Tree
**When to use:** Problems on binary trees where answer depends on children.  
**State meaning:** Often `dfs(node)` returns something, sometimes with multiple states (rob/skip).

```cpp
// House Robber III
pair<int,int> dfs(TreeNode* node) {
    if (!node) return {0,0};
    auto left = dfs(node->left);
    auto right = dfs(node->right);
    int rob = node->val + left.second + right.second;
    int skip = max(left.first, left.second) + max(right.first, right.second);
    return {rob, skip};
}
int rob(TreeNode* root) {
    auto res = dfs(root);
    return max(res.first, res.second);
}
```

**Key insight:** Post-order traversal, combine children results.

---

### 5.2 General Tree (N-ary)
**When to use:** Problems on trees with many children.  
**State meaning:** Similar to binary tree but iterate over children.

```cpp
// Sum of Distances in Tree (rerooting DP)
vector<int> sumOfDistancesInTree(int n, vector<vector<int>>& edges) {
    vector<vector<int>> graph(n);
    for (auto& e : edges) {
        graph[e[0]].push_back(e[1]);
        graph[e[1]].push_back(e[0]);
    }
    vector<int> count(n, 1), ans(n, 0);
    // first DFS to compute count and ans for root
    function<void(int,int)> dfs1 = [&](int u, int parent) {
        for (int v : graph[u]) {
            if (v == parent) continue;
            dfs1(v, u);
            count[u] += count[v];
            ans[u] += ans[v] + count[v];
        }
    };
    // second DFS to reroot
    function<void(int,int)> dfs2 = [&](int u, int parent) {
        for (int v : graph[u]) {
            if (v == parent) continue;
            ans[v] = ans[u] - count[v] + (n - count[v]);
            dfs2(v, u);
        }
    };
    dfs1(0, -1);
    dfs2(0, -1);
    return ans;
}
```

**Key insight:** Use rerooting technique: compute for root, then adjust for each child.

---

### 5.3 Binary Search Tree
**When to use:** Counting unique BSTs with given nodes.  
**State meaning:** `dp[n]` = number of BSTs with n nodes.

```cpp
int numTrees(int n) {
    vector<int> dp(n+1, 0);
    dp[0] = dp[1] = 1;
    for (int i = 2; i <= n; ++i)
        for (int j = 1; j <= i; ++j)
            dp[i] += dp[j-1] * dp[i-j];
    return dp[n];
}
```

**Key insight:** Catalan number; choose root, left and right are smaller subproblems.

---

## ðŸŸ¢ Pattern 6 â€” Knapsack / Subset Sum

### 6.1 0/1 Knapsack
**When to use:** Each item can be used at most once.  
**State meaning:** `dp[i][w]` = max value with first i items and capacity w (or `dp[w]` after space optimization).

```cpp
// Partition Equal Subset Sum
bool canPartition(vector<int>& nums) {
    int sum = accumulate(nums.begin(), nums.end(), 0);
    if (sum % 2) return false;
    int target = sum / 2;
    vector<bool> dp(target+1, false);
    dp[0] = true;
    for (int num : nums) {
        for (int w = target; w >= num; --w) {
            dp[w] = dp[w] || dp[w - num];
        }
    }
    return dp[target];
}
```

**Key insight:** Iterate capacity backwards to avoid reusing same item.

---

### 6.2 Unbounded Knapsack
**When to use:** Each item can be used unlimited times.  
**State meaning:** `dp[w]` = ways / min coins for capacity w.

```cpp
// Coin Change (minimum coins)
int coinChange(vector<int>& coins, int amount) {
    vector<int> dp(amount+1, amount+1);
    dp[0] = 0;
    for (int w = 1; w <= amount; ++w) {
        for (int c : coins) {
            if (c <= w) dp[w] = min(dp[w], dp[w-c] + 1);
        }
    }
    return dp[amount] > amount ? -1 : dp[amount];
}

// Coin Change II (number of combinations)
int change(int amount, vector<int>& coins) {
    vector<int> dp(amount+1, 0);
    dp[0] = 1;
    for (int c : coins) {
        for (int w = c; w <= amount; ++w) {
            dp[w] += dp[w - c];
        }
    }
    return dp[amount];
}
```

**Key insight:** For combinations (order doesn't matter), iterate coins first then capacity; for permutations, iterate capacity then coins.

---

### 6.3 Subset Sum
**When to use:** Determine if a subset sums to target.  
**State meaning:** `dp[w]` = whether sum w is achievable.

```cpp
// Already shown in 0/1 knapsack example.
```

**Key insight:** Same as 0/1 knapsack but with boolean.

---

## ðŸŸ¢ Pattern 7 â€” State Machine / Finite Automata

### 7.1 Stock (already covered)
### 7.2 Regular Expression / Wildcard
**When to use:** String matching with * and .  
**State meaning:** `dp[i][j]` = whether s[0..i-1] matches p[0..j-1].

```cpp
// Wildcard Matching
bool isMatch(string s, string p) {
    int m = s.size(), n = p.size();
    vector<vector<bool>> dp(m+1, vector<bool>(n+1, false));
    dp[0][0] = true;
    for (int j = 1; j <= n; ++j) {
        if (p[j-1] == '*') dp[0][j] = dp[0][j-1];
    }
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (p[j-1] == '*') {
                dp[i][j] = dp[i-1][j] || dp[i][j-1];
            } else if (p[j-1] == '?' || s[i-1] == p[j-1]) {
                dp[i][j] = dp[i-1][j-1];
            }
        }
    }
    return dp[m][n];
}
```

**Key insight:** Handle '*' carefully: it can match zero or more characters.

---

### 7.3 Valid Parentheses / Encoding
**When to use:** Problems about valid parentheses strings.  
**State meaning:** `dp[i]` = longest valid parentheses ending at i, or number of ways.

```cpp
// Longest Valid Parentheses
int longestValidParentheses(string s) {
    int n = s.size(), best = 0;
    vector<int> dp(n, 0);
    for (int i = 1; i < n; ++i) {
        if (s[i] == ')') {
            if (s[i-1] == '(') {
                dp[i] = (i >= 2 ? dp[i-2] : 0) + 2;
            } else if (i - dp[i-1] > 0 && s[i - dp[i-1] - 1] == '(') {
                dp[i] = dp[i-1] + 2 + (i - dp[i-1] >= 2 ? dp[i - dp[i-1] - 2] : 0);
            }
            best = max(best, dp[i]);
        }
    }
    return best;
}
```

**Key insight:** Use stack is easier, but DP works by checking previous matches.

---

### 7.4 Special Sequences
**When to use:** Problems where state includes last character or some flag.  
**State meaning:** `dp[i][state]` = number of ways up to i with given state.

```cpp
// Student Attendance Record II
int checkRecord(int n) {
    const int MOD = 1e9+7;
    // dp[i][A][L] = ways for length i with A absences and trailing L lates
    vector<vector<vector<long>>> dp(n+1, vector<vector<long>>(2, vector<long>(3,0)));
    dp[0][0][0] = 1;
    for (int i = 0; i < n; ++i) {
        for (int A = 0; A <= 1; ++A) {
            for (int L = 0; L <= 2; ++L) {
                if (dp[i][A][L] == 0) continue;
                // add 'P'
                dp[i+1][A][0] = (dp[i+1][A][0] + dp[i][A][L]) % MOD;
                // add 'A'
                if (A < 1) dp[i+1][A+1][0] = (dp[i+1][A+1][0] + dp[i][A][L]) % MOD;
                // add 'L'
                if (L < 2) dp[i+1][A][L+1] = (dp[i+1][A][L+1] + dp[i][A][L]) % MOD;
            }
        }
    }
    long ans = 0;
    for (int A = 0; A <= 1; ++A)
        for (int L = 0; L <= 2; ++L)
            ans = (ans + dp[n][A][L]) % MOD;
    return ans;
}
```

**Key insight:** Encode all constraints into state dimensions.

---

## ðŸŸ¢ Pattern 8 â€” Digit DP

**When to use:** Count numbers in a range satisfying digit-related conditions.  
**State meaning:** `dp[pos][tight][leadingZero][...]` = count of numbers from current position.

```cpp
// Count numbers with at most one non-zero digit? But general template:
int countNumbersWithUniqueDigits(int n) {
    if (n == 0) return 1;
    vector<int> digits;
    for (int i = 1; i <= n; ++i) digits.push_back(9); // not exactly, but for illustration
    // memo[pos][mask][tight][leadingZero]
    function<int(int,int,bool,bool)> dfs = [&](int pos, int mask, bool tight, bool leadingZero) -> int {
        if (pos == digits.size()) return 1;
        int limit = tight ? digits[pos] : 9;
        int res = 0;
        for (int d = 0; d <= limit; ++d) {
            if (!leadingZero && (mask & (1<<d))) continue;
            bool newTight = tight && (d == limit);
            bool newLead = leadingZero && (d == 0);
            int newMask = (leadingZero && d==0) ? mask : (mask | (1<<d));
            res += dfs(pos+1, newMask, newTight, newLead);
        }
        return res;
    };
    return dfs(0, 0, true, true);
}
```

**Key insight:** Parameters: position, mask of used digits, tight bound, leading zero flag. Memoize.

---

## ðŸŸ¢ Pattern 9 â€” Bitmask DP / TSP

### 9.1 TSP / Permutations
**When to use:** Problems requiring visiting a set of nodes exactly once, minimizing cost.  
**State meaning:** `dp[mask][last]` = min cost to visit set mask ending at last.

```cpp
// Shortest Path Visiting All Nodes (simplified TSP)
int shortestPathLength(vector<vector<int>>& graph) {
    int n = graph.size();
    int target = (1 << n) - 1;
    vector<vector<int>> dp(1<<n, vector<int>(n, INT_MAX));
    queue<pair<int,int>> q;
    for (int i = 0; i < n; ++i) {
        dp[1<<i][i] = 0;
        q.push({1<<i, i});
    }
    while (!q.empty()) {
        auto [mask, u] = q.front(); q.pop();
        int dist = dp[mask][u];
        if (mask == target) return dist;
        for (int v : graph[u]) {
            int nextMask = mask | (1 << v);
            if (dp[nextMask][v] > dist + 1) {
                dp[nextMask][v] = dist + 1;
                q.push({nextMask, v});
            }
        }
    }
    return -1;
}
```

**Key insight:** Use BFS on state space (mask, node) for unweighted; for weighted, use Floyd or DP with relaxation.

---

### 9.2 Subset DP
**When to use:** Partition array into subsets with equal sum, etc.  
**State meaning:** `dp[mask]` = best value for subset.

```cpp
// Partition to K Equal Sum Subsets (bitmask + recursion)
bool canPartitionKSubsets(vector<int>& nums, int k) {
    int sum = accumulate(nums.begin(), nums.end(), 0);
    if (sum % k) return false;
    int target = sum / k;
    int n = nums.size();
    vector<int> dp(1<<n, -1);
    dp[0] = 0;
    for (int mask = 0; mask < (1<<n); ++mask) {
        if (dp[mask] == -1) continue;
        for (int i = 0; i < n; ++i) {
            if (!(mask & (1<<i)) && dp[mask] + nums[i] <= target) {
                int nextMask = mask | (1<<i);
                dp[nextMask] = (dp[mask] + nums[i]) % target;
            }
        }
    }
    return dp[(1<<n)-1] == 0;
}
```

**Key insight:** Use sum modulo target to represent current subset sum.

---

## ðŸŸ¢ Pattern 10 â€” DP on Intervals / Range

### 10.1 Scheduling / Meeting rooms
**When to use:** Maximum profit from non-overlapping intervals.  
**State meaning:** `dp[i]` = max profit up to job i (sorted by end time).

```cpp
// Maximum Profit in Job Scheduling
int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {
    int n = startTime.size();
    vector<vector<int>> jobs;
    for (int i = 0; i < n; ++i)
        jobs.push_back({startTime[i], endTime[i], profit[i]});
    sort(jobs.begin(), jobs.end(), [](auto& a, auto& b) { return a[1] < b[1]; });
    vector<int> dp(n);
    dp[0] = jobs[0][2];
    for (int i = 1; i < n; ++i) {
        int inc = jobs[i][2];
        // find last job with end <= start[i]
        int lo = 0, hi = i-1, idx = -1;
        while (lo <= hi) {
            int mid = (lo+hi)/2;
            if (jobs[mid][1] <= jobs[i][0]) {
                idx = mid;
                lo = mid+1;
            } else hi = mid-1;
        }
        if (idx != -1) inc += dp[idx];
        dp[i] = max(dp[i-1], inc);
    }
    return dp[n-1];
}
```

**Key insight:** Sort by end time, binary search for compatible previous job.

---

### 10.2 Merge / Partition
**When to use:** Splitting array into segments with cost.  
**State meaning:** `dp[i]` = min cost for first i elements.

```cpp
// Minimum Difficulty of a Job Schedule
int minDifficulty(vector<int>& jobDifficulty, int d) {
    int n = jobDifficulty.size();
    if (n < d) return -1;
    vector<vector<int>> dp(d+1, vector<int>(n+1, INT_MAX/2));
    dp[0][0] = 0;
    for (int day = 1; day <= d; ++day) {
        for (int i = day; i <= n; ++i) {
            int maxd = 0;
            for (int j = i; j >= day; --j) {
                maxd = max(maxd, jobDifficulty[j-1]);
                dp[day][i] = min(dp[day][i], dp[day-1][j-1] + maxd);
            }
        }
    }
    return dp[d][n];
}
```

**Key insight:** Iterate over last segment start.

---

## ðŸŸ¢ Pattern 11 â€” Probability / Expectation DP

**When to use:** Problems involving probabilities or expected values.  
**State meaning:** `dp[i]` = probability/expectation for state i.

```cpp
// Knight Probability in Chessboard
double knightProbability(int n, int k, int row, int column) {
    vector<vector<double>> dp(n, vector<double>(n, 0));
    dp[row][column] = 1.0;
    int dirs[8][2] = {{1,2},{1,-2},{-1,2},{-1,-2},{2,1},{2,-1},{-2,1},{-2,-1}};
    for (int step = 0; step < k; ++step) {
        vector<vector<double>> newDp(n, vector<double>(n, 0));
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (dp[i][j] > 0) {
                    for (auto& d : dirs) {
                        int ni = i + d[0], nj = j + d[1];
                        if (ni >= 0 && ni < n && nj >= 0 && nj < n) {
                            newDp[ni][nj] += dp[i][j] / 8.0;
                        }
                    }
                }
            }
        }
        dp = move(newDp);
    }
    double ans = 0;
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            ans += dp[i][j];
    return ans;
}
```

**Key insight:** Often use iterative DP updating probabilities.

---

## ðŸŸ¢ Pattern 12 â€” Special / Miscellaneous

### 12.1 Ugly Numbers
**When to use:** Generate nth ugly number (factors only 2,3,5).  
**State meaning:** `dp[i]` = ith ugly number.

```cpp
int nthUglyNumber(int n) {
    vector<int> dp(n);
    dp[0] = 1;
    int i2 = 0, i3 = 0, i5 = 0;
    for (int i = 1; i < n; ++i) {
        int next2 = dp[i2] * 2, next3 = dp[i3] * 3, next5 = dp[i5] * 5;
        dp[i] = min({next2, next3, next5});
        if (dp[i] == next2) ++i2;
        if (dp[i] == next3) ++i3;
        if (dp[i] == next5) ++i5;
    }
    return dp[n-1];
}
```

**Key insight:** Three pointers method.

---

### 12.2 Edit Distance
**When to use:** Minimum operations to convert string A to B.  
**State meaning:** `dp[i][j]` = min edits for first i of A and first j of B.

```cpp
int minDistance(string word1, string word2) {
    int m = word1.size(), n = word2.size();
    vector<vector<int>> dp(m+1, vector<int>(n+1));
    for (int i = 0; i <= m; ++i) dp[i][0] = i;
    for (int j = 0; j <= n; ++j) dp[0][j] = j;
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (word1[i-1] == word2[j-1])
                dp[i][j] = dp[i-1][j-1];
            else
                dp[i][j] = 1 + min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]});
        }
    }
    return dp[m][n];
}
```

**Key insight:** Insert, delete, replace correspond to dp transitions.

---

### 12.3 Others
For other special problems like **Race Car**, **Super Egg Drop**, etc., the state and transitions are highly problem-specific. Always start by defining the state (what you need to know) and then think about how to transition from smaller subproblems.

---

## âœ… Summary

- **Every DP problem** can be categorized into one of these patterns.
- **Template** helps you quickly set up the DP array and loops.
- **Key insight** is the transition logic.

Use this guide as a reference when you encounter a new DP problem: first identify the pattern, then adapt the corresponding template.

If you need a template for a specific problem not covered here, feel free to ask!
